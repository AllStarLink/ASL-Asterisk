--- a/include/asterisk/features.h
+++ b/include/asterisk/features.h
@@ -47,6 +47,8 @@ struct ast_call_feature {
 };
 
 
+extern int ast_autoanswer_login(struct ast_channel *chan, void *data);
+extern int ast_masq_autoanswer_login(struct ast_channel *rchan, void *data);
 
 /*! \brief Park a call and read back parked location 
  *  \param chan the channel to actually be parked
--- a/res/res_features.c
+++ b/res/res_features.c
@@ -11,6 +11,10 @@
  * the project provides a web site, mailing lists and IRC
  * channels for your use.
  *
+ * Copyright (C) 2004, Junghanns.NET GmbH
+ *
+ * Klaus-Peter Junghanns <kpj@junghanns.net>
+ *
  * This program is free software, distributed under the terms of
  * the GNU General Public License Version 2. See the LICENSE file
  * at the top of the source tree.
@@ -132,6 +136,20 @@ static char *descrip2 = "Park():"
 "it already exists. In that case, execution will continue at next\n"
 "priority.\n" ;
 
+static char *autoanswerlogin = "AutoanswerLogin";
+
+static char *synopsis3 = "Log in for autoanswer";
+
+static char *descrip3 = "AutoanswerLogin([context]|exten):"
+"Used to login to the autoanswer application for an extension.\n";
+
+static char *autoanswer = "Autoanswer";
+
+static char *synopsis4 = "Autoanswer a call";
+
+static char *descrip4 = "Autoanswer([context]|exten):"
+"Used to autoanswer a call for an extension.\n";
+
 static struct ast_app *monitor_app = NULL;
 static int monitor_ok = 1;
 
@@ -150,6 +168,23 @@ struct parkeduser {
 	struct parkeduser *next;
 };
 
+/* auto answer user */
+struct aauser {
+	struct ast_channel *chan;
+	struct timeval start;
+	/* waiting on this extension/context */
+	char exten[AST_MAX_EXTENSION];
+	char context[AST_MAX_EXTENSION];
+	int priority;
+	int notquiteyet;
+	struct aauser *next;
+};
+
+
+static struct aauser *aalot;
+AST_MUTEX_DEFINE_STATIC(autoanswer_lock);
+static pthread_t autoanswer_thread;
+
 static struct parkeduser *parkinglot;
 
 AST_MUTEX_DEFINE_STATIC(parking_lock);	/*!< protects all static variables above */
@@ -405,11 +440,13 @@ static int park_call_full(struct ast_cha
 		"From: %s\r\n"
 		"Timeout: %ld\r\n"
 		"CallerID: %s\r\n"
-		"CallerIDName: %s\r\n",
+		"CallerIDName: %s\r\n"
+		"Uniqueid: %s\r\n",
 		pu->parkingexten, pu->chan->name, peer ? peer->name : "",
 		(long)pu->start.tv_sec + (long)(pu->parkingtime/1000) - (long)time(NULL),
 		S_OR(pu->chan->cid.cid_num, "<unknown>"),
-		S_OR(pu->chan->cid.cid_name, "<unknown>")
+		S_OR(pu->chan->cid.cid_name, "<unknown>"),
+		pu->chan->uniqueid
 		);
 
 	if (peer && adsipark && ast_adsi_available(peer)) {
@@ -1656,11 +1693,13 @@ static void post_manager_event(const cha
 		"Exten: %s\r\n"
 		"Channel: %s\r\n"
 		"CallerID: %s\r\n"
-		"CallerIDName: %s\r\n\r\n",
+		"CallerIDName: %s\r\n"
+		"Uniqueid: %s\r\n\r\n",
 		parkingexten, 
 		chan->name,
 		S_OR(chan->cid.cid_num, "<unknown>"),
-		S_OR(chan->cid.cid_name, "<unknown>")
+		S_OR(chan->cid.cid_name, "<unknown>"),
+		chan->uniqueid
 		);
 }
 
@@ -1928,10 +1967,12 @@ static int park_exec(struct ast_channel 
 			"Channel: %s\r\n"
 			"From: %s\r\n"
 			"CallerID: %s\r\n"
-			"CallerIDName: %s\r\n",
+			"CallerIDName: %s\r\n"
+			"Uniqueid: %s\r\n",
 			pu->parkingexten, pu->chan->name, chan->name,
 			S_OR(pu->chan->cid.cid_num, "<unknown>"),
-			S_OR(pu->chan->cid.cid_name, "<unknown>")
+			S_OR(pu->chan->cid.cid_name, "<unknown>"),
+			pu->chan->uniqueid
 			);
 
 		free(pu);
@@ -2085,15 +2126,10 @@ static struct ast_cli_entry cli_show_fea
 	handle_showfeatures, NULL,
 	NULL };
 
-static struct ast_cli_entry cli_features[] = {
-	{ { "feature", "show", NULL },
-	handle_showfeatures, "Lists configured features",
-	showfeatures_help, NULL, &cli_show_features_deprecated },
+static char showautoanswer_help[] =
+"Usage: show autoanswer\n"
+"       Lists currently logged in autoanswer users.\n";
 
-	{ { "show", "parkedcalls", NULL },
-	handle_parkedcalls, "Lists parked calls",
-	showparked_help },
-};
 
 /*! \brief Dump lot status */
 static int manager_parking_status( struct mansession *s, const struct message *m)
@@ -2117,12 +2153,13 @@ static int manager_parking_status( struc
 			"Timeout: %ld\r\n"
 			"CallerID: %s\r\n"
 			"CallerIDName: %s\r\n"
+			"Uniqueid: %s\r\n\r\n"
 			"%s"
 			"\r\n",
 			cur->parkingnum, cur->chan->name, cur->peername,
 			(long) cur->start.tv_sec + (long) (cur->parkingtime / 1000) - (long) time(NULL),
 			S_OR(cur->chan->cid.cid_num, ""),	/* XXX in other places it is <unknown> */
-			S_OR(cur->chan->cid.cid_name, ""),
+			S_OR(cur->chan->cid.cid_name, ""), cur->chan->uniqueid,
 			idText);
 	}
 
@@ -2197,6 +2234,427 @@ static int manager_park(struct mansessio
 	return 0;
 }
 
+static int handle_autoanswer(int fd, int argc, char *argv[])
+{
+	struct aauser *cur;
+
+	ast_cli(fd, "%25s %10s %15s \n", "Channel"
+		, "Extension", "Context");
+
+	ast_mutex_lock(&autoanswer_lock);
+
+	cur=aalot;
+	while(cur) {
+		ast_cli(fd, "%25s %10s %15s\n",cur->chan->name, cur->exten, cur->context);
+
+		cur = cur->next;
+	}
+
+	ast_mutex_unlock(&autoanswer_lock);
+
+	return RESULT_SUCCESS;
+}
+
+static struct ast_cli_entry cli_features[] = {
+	{ { "feature", "list", NULL },
+	handle_showfeatures, "Lists configured features",
+	showfeatures_help, NULL, &cli_show_features_deprecated },
+
+	{ { "show", "parkedcalls", NULL },
+	handle_parkedcalls, "Lists parked calls",
+	showparked_help },
+
+	{ { "show", "autoanswer", NULL },
+	handle_autoanswer, "Lists autoanswer users",
+	showautoanswer_help },
+};
+int ast_masq_autoanswer_login(struct ast_channel *rchan, void *data)
+{
+	struct ast_channel *chan;
+	struct ast_frame *f;
+	/* Make a new, fake channel that we'll use to masquerade in the real one */
+	chan = ast_channel_alloc(0, AST_STATE_DOWN, 0, 0, "", "", "", 0, "Autoanswer/%s", rchan->name);
+	if (chan) {
+		/* Let us keep track of the channel name */
+		ast_string_field_build(chan, name, "Autoanswer/%s",rchan->name);
+		/* Make formats okay */
+		chan->readformat = rchan->readformat;
+		chan->writeformat = rchan->writeformat;
+		ast_channel_masquerade(chan, rchan);
+		/* Setup the extensions and such */
+		strncpy(chan->context, rchan->context, sizeof(chan->context) - 1);
+		strncpy(chan->exten, rchan->exten, sizeof(chan->exten) - 1);
+		chan->priority = rchan->priority;
+		/* might be dirty but we want trackable channels */
+		ast_string_field_build(chan, uniqueid, "%s",rchan->uniqueid);
+		/* Make the masq execute */
+		f = ast_read(chan);
+		if (f)
+			ast_frfree(f);
+		ast_autoanswer_login(chan, data);
+	} else {
+		ast_log(LOG_WARNING, "Unable to create aa channel\n");
+		return -1;
+	}
+	return 0;
+}
+
+static int autoanswer_login_exec(struct ast_channel *chan, void *data)
+{
+	int res=0;
+	struct ast_module_user *u;
+
+	u = ast_module_user_add(chan);
+	if (!data) {
+		ast_log(LOG_WARNING, "AutoanswerLogin requires an argument (extension number)\n");
+		return -1;
+	}
+	res = ast_masq_autoanswer_login(chan, data);
+	ast_module_user_remove(u);
+	return res;
+}
+
+int ast_autoanswer_login(struct ast_channel *chan, void *data)
+{
+	/* We put the user in the parking list, then wake up the parking thread to be sure it looks
+	   after these channels too */
+	struct ast_context *con;
+	char exten[AST_MAX_EXTENSION];
+	struct aauser *pu,*pl = NULL;
+	char *s, *stringp, *aacontext, *aaexten = NULL;
+
+	s = ast_strdupa((void *) data);
+	stringp=s;
+	aacontext = strsep(&stringp, "|");
+	aaexten = strsep(&stringp, "|");
+	if (!aaexten) {
+	    aaexten = aacontext;
+	    aacontext = NULL;
+	}
+	if (!aaexten) {
+		ast_log(LOG_WARNING, "AutoanswerLogin requires at least an extension!\n");
+		return -1;
+	} else {
+		if (!aacontext) {
+			aacontext = "default";
+		}
+	}
+
+	ast_mutex_lock(&autoanswer_lock);
+	pu = aalot;
+	while(pu) {
+		if ((!strncasecmp(pu->exten, aaexten, sizeof(pu->exten)-1)) && (!strncasecmp(pu->context, aacontext, sizeof(pu->context)-1))){
+			if (pl)
+				pl->next = pu->next;
+			else
+				aalot = pu->next;
+			break;
+		}
+		pl = pu;
+		pu = pu->next;
+	}
+	ast_mutex_unlock(&autoanswer_lock);
+	if (pu) {
+	    ast_log(LOG_NOTICE, "Logout old Channel %s for %s@%s.\n",pu->chan->name, pu->exten, pu->context);
+	    manager_event(EVENT_FLAG_CALL, "AutoanswerLogout",
+                    			    "Channel: %s\r\n"
+                    			    "Uniqueid: %s\r\n"
+                    			    "Context: %s\r\n"
+                    			    "Exten: %s\r\n"
+                    			,pu->chan->name, pu->chan->uniqueid, pu->context, pu->exten);
+	    ast_hangup(pu->chan);
+	    free(pu);
+	}
+	pu = malloc(sizeof(struct aauser));
+	if (pu) {
+		memset(pu, 0, sizeof(pu));
+		ast_mutex_lock(&autoanswer_lock);
+		chan->appl = "Autoanswer";
+		chan->data = NULL;
+
+		pu->chan = chan;
+		if (chan->_state != AST_STATE_UP) {
+		    ast_answer(chan);
+		}
+
+		/* Start music on hold */
+		ast_moh_start(pu->chan, NULL, NULL);
+		gettimeofday(&pu->start, NULL);
+		strncpy(pu->exten, aaexten, sizeof(pu->exten)-1);
+		strncpy(pu->context, aacontext, sizeof(pu->exten)-1);
+		pu->next = aalot;
+		aalot = pu;
+		con = ast_context_find(aacontext);
+		if (!con) {
+			con = ast_context_create(NULL,aacontext, registrar);
+			if (!con) {
+				ast_log(LOG_ERROR, "Context '%s' does not exist and unable to create\n", aacontext);
+			}
+		}
+		if (con) {
+			snprintf(exten, sizeof(exten), "%s", aaexten);
+			ast_add_extension2(con, 1, exten, 1, NULL, NULL, autoanswer, strdup((char *)data), free, registrar);
+		}
+
+		ast_mutex_unlock(&autoanswer_lock);
+		/* Wake up the (presumably select()ing) thread */
+		pthread_kill(autoanswer_thread, SIGURG);
+		if (option_verbose > 1)
+			ast_verbose(VERBOSE_PREFIX_2 "Autoanswer login from %s for %s@%s.\n", pu->chan->name, pu->exten, pu->context);
+			manager_event(EVENT_FLAG_CALL, "AutoanswerLogin",
+                                "Channel: %s\r\n"
+                                "Uniqueid: %s\r\n"
+        			"Context: %s\r\n"
+                    		"Exten: %s\r\n"
+                    		,pu->chan->name, pu->chan->uniqueid, pu->context, pu->exten);
+
+			return 0;
+	} else {
+		ast_log(LOG_WARNING, "Out of memory\n");
+		return -1;
+	}
+	return 0;
+}
+
+static void autoanswer_reregister_extensions(void)
+{
+	struct aauser *cur;
+	struct ast_context *con;
+	char exten[AST_MAX_EXTENSION];
+	char args[AST_MAX_EXTENSION];
+
+	ast_mutex_lock(&autoanswer_lock);
+
+	cur=aalot;
+	while(cur) {
+		con = ast_context_find(cur->context);
+		if (!con) {
+			con = ast_context_create(NULL,cur->context, registrar);
+			if (!con) {
+				ast_log(LOG_ERROR, "Context '%s' does not exist and unable to create\n", cur->context);
+			}
+		}
+		if (con) {
+			snprintf(exten, sizeof(exten), "%s", cur->exten);
+			snprintf(args, sizeof(args), "%s|%s", cur->context, cur->exten);
+			ast_add_extension2(con, 1, exten, 1, NULL, NULL, autoanswer, strdup((char *)args), free, registrar);
+		}
+		cur = cur->next;
+	}
+
+	ast_mutex_unlock(&autoanswer_lock);
+}
+static void *do_autoanswer_thread(void *ignore)
+{
+	int ms, tms, max;
+	struct ast_context *con;
+	char exten[AST_MAX_EXTENSION];
+	struct aauser *pu, *pl, *pt = NULL;
+	struct timeval tv;
+	struct ast_frame *f;
+	int x;
+	fd_set rfds, efds;
+	fd_set nrfds, nefds;
+	FD_ZERO(&rfds);
+	FD_ZERO(&efds);
+	for (;;) {
+		ms = -1;
+		max = -1;
+		ast_mutex_lock(&autoanswer_lock);
+		pl = NULL;
+		pu = aalot;
+		gettimeofday(&tv, NULL);
+		FD_ZERO(&nrfds);
+		FD_ZERO(&nefds);
+		while(pu) {
+			tms = (tv.tv_sec - pu->start.tv_sec) * 1000 + (tv.tv_usec - pu->start.tv_usec) / 1000;
+			for (x=0;x<AST_MAX_FDS;x++) {
+				if ((pu->chan->fds[x] > -1) && (FD_ISSET(pu->chan->fds[x], &rfds) || FD_ISSET(pu->chan->fds[x], &efds))) {
+					if (FD_ISSET(pu->chan->fds[x], &efds))
+						ast_set_flag(pu->chan, AST_FLAG_EXCEPTION);
+					else
+						ast_clear_flag(pu->chan, AST_FLAG_EXCEPTION);
+					pu->chan->fdno = x;
+					/* See if they need servicing */
+					f = ast_read(pu->chan);
+					if (!f || ((f->frametype == AST_FRAME_CONTROL) && (f->subclass ==  AST_CONTROL_HANGUP))) {
+						/* There's a problem, hang them up*/
+						if (option_verbose > 1)
+							ast_verbose(VERBOSE_PREFIX_2 "%s logged out of autoanswer app\n", pu->chan->name);
+						manager_event(EVENT_FLAG_CALL, "AutoanswerLogout",
+                            			    "Channel: %s\r\n"
+                            			    "Uniqueid: %s\r\n"
+                    				    "Context: %s\r\n"
+                    				    "Exten: %s\r\n"
+                    				,pu->chan->name, pu->chan->uniqueid, pu->context, pu->exten);
+						ast_hangup(pu->chan);
+						con = ast_context_find(pu->context);
+						if (con) {
+						    snprintf(exten, sizeof(exten), "%s", pu->exten);
+						    if (ast_context_remove_extension2(con, exten, 1, registrar))
+							ast_log(LOG_WARNING, "Whoa, failed to remove the extension!\n");
+						} else {
+							ast_log(LOG_WARNING, "Whoa, no %s context?\n", pu->exten);
+						}
+						/* And take them out of the parking lot */
+						if (pl)
+							pl->next = pu->next;
+						else
+							aalot = pu->next;
+						pt = pu;
+						pu = pu->next;
+						free(pt);
+						break;
+					} else {
+						/* XXX Maybe we could do something with packets, like dial "0" for operator or something XXX */
+						ast_frfree(f);
+						goto std;	/* XXX Ick: jumping into an else statement??? XXX */
+					}
+				}
+			}
+			if (x >= AST_MAX_FDS) {
+std:				for (x=0;x<AST_MAX_FDS;x++) {
+					/* Keep this one for next one */
+					if (pu->chan->fds[x] > -1) {
+						FD_SET(pu->chan->fds[x], &nrfds);
+						FD_SET(pu->chan->fds[x], &nefds);
+						if (pu->chan->fds[x] > max)
+							max = pu->chan->fds[x];
+					}
+				}
+				/* Keep track of our longest wait */
+				if ((tms < ms) || (ms < 0))
+					ms = tms;
+				pl = pu;
+				pu = pu->next;
+			}
+		}
+		ast_mutex_unlock(&autoanswer_lock);
+		rfds = nrfds;
+		efds = nefds;
+		tv.tv_sec = ms / 1000;
+		tv.tv_usec = (ms % 1000) * 1000;
+		/* Wait for something to happen */
+		ast_select(max + 1, &rfds, NULL, &efds, (ms > -1) ? &tv : NULL);
+		pthread_testcancel();
+	}
+	return NULL;	/* Never reached */
+}
+
+static int autoanswer_exec(struct ast_channel *chan, void *data)
+{
+	int res=0;
+	struct ast_channel *peer=NULL;
+	struct aauser *pu, *pl=NULL;
+	struct ast_bridge_config config;
+	char *s, *stringp, *aacontext, *aaexten = NULL;
+	char datastring[80];
+	struct ast_module_user *u;
+
+
+	if (!data) {
+		ast_log(LOG_WARNING, "Autoanswer requires an argument (extension number)\n");
+		return -1;
+	}
+	s = ast_strdupa((void *) data);
+	stringp=s;
+	aacontext = strsep(&stringp, "|");
+	aaexten = strsep(&stringp, "|");
+	if (!aaexten) {
+	    aaexten = aacontext;
+	    aacontext = NULL;
+	}
+	if (!aaexten) {
+		ast_log(LOG_WARNING, "AutoanswerLogin requires at least an extension!\n");
+		return -1;
+	} else {
+		if (!aacontext) {
+			aacontext = "default";
+		}
+	}
+
+	u = ast_module_user_add(chan);
+	ast_mutex_lock(&autoanswer_lock);
+	pu = aalot;
+	while(pu) {
+		if ((!strncasecmp(pu->exten, aaexten, sizeof(pu->exten)-1)) && (!strncasecmp(pu->context, aacontext, sizeof(pu->context)-1))){
+			if (pl)
+				pl->next = pu->next;
+			else
+				aalot = pu->next;
+			break;
+		}
+		pl = pu;
+		pu = pu->next;
+	}
+	ast_mutex_unlock(&autoanswer_lock);
+	if (pu) {
+		peer = pu->chan;
+		free(pu);
+		pu = NULL;
+	}
+	/* JK02: it helps to answer the channel if not already up */
+	if (chan->_state != AST_STATE_UP) {
+		ast_answer(chan);
+	}
+
+	if (peer) {
+		ast_moh_stop(peer);
+		/* Play a courtesy beep in the callED channel to prefix the bridge connecting */
+		if (!ast_strlen_zero(courtesytone)) {
+			if (!ast_streamfile(peer, courtesytone, peer->language)) {
+				if (ast_waitstream(peer, "") < 0) {
+					ast_log(LOG_WARNING, "Failed to play courtesy tone!\n");
+					ast_hangup(peer);
+					return -1;
+				}
+			}
+		}
+
+		res = ast_channel_make_compatible(chan, peer);
+		if (res < 0) {
+			ast_log(LOG_WARNING, "Could not make channels %s and %s compatible for bridge\n", chan->name, peer->name);
+			ast_hangup(peer);
+			return -1;
+		}
+		/* This runs sorta backwards, since we give the incoming channel control, as if it
+		   were the person called. */
+		if (option_verbose > 2)
+			ast_verbose(VERBOSE_PREFIX_3 "Channel %s autoanswered  %s\n", peer->name, chan->name);
+		manager_event(EVENT_FLAG_CALL, "Autoanswer",
+                    "Channel: %s\r\n"
+                    "Uniqueid: %s\r\n"
+                    "Channel2: %s\r\n"
+                    "Uniqueid2: %s\r\n"
+                    "Context: %s\r\n"
+                    "Exten: %s\r\n"
+                ,chan->name, chan->uniqueid, peer->name, peer->uniqueid, aacontext, aaexten);
+
+
+		memset(&config,0,sizeof(struct ast_bridge_config));
+		ast_set_flag(&(config.features_callee), AST_FEATURE_REDIRECT);
+		ast_set_flag(&(config.features_caller), AST_FEATURE_REDIRECT);
+		config.timelimit = 0;
+		config.play_warning = 0;
+		config.warning_freq = 0;
+		config.warning_sound=NULL;
+		res = ast_bridge_call(chan,peer,&config);
+
+		if (option_verbose > 2)
+			ast_verbose(VERBOSE_PREFIX_3 "returning from bridge %s\n", peer->name);
+			/* relogin */
+		snprintf(datastring, sizeof(datastring) - 1, "%s|%s", aacontext, aaexten);
+		ast_autoanswer_login(peer, datastring);
+		return res;
+	} else {
+		if (option_verbose > 2)
+			ast_verbose(VERBOSE_PREFIX_3 "Nobody logged in for autoanswer %s@%s\n", aaexten, aacontext);
+		res = -1;
+	}
+	ast_module_user_remove(u);
+	return res;
+}
+
 
 int ast_pickup_call(struct ast_channel *chan)
 {
@@ -2460,6 +2918,7 @@ static int load_config(void) 
 
 static int reload(void)
 {
+	autoanswer_reregister_extensions();
 	return load_config();
 }
 
@@ -2483,6 +2942,12 @@ static int load_module(void)
 			"Park a channel", mandescr_park); 
 	}
 
+	ast_pthread_create(&autoanswer_thread, NULL, do_autoanswer_thread, NULL);
+	if (!res)
+		res |= ast_register_application(autoanswerlogin, autoanswer_login_exec, synopsis3, descrip3);
+	if (!res)
+		res |= ast_register_application(autoanswer, autoanswer_exec, synopsis4, descrip4);
+
 	res |= ast_devstate_prov_add("Park", metermaidstate);
 
 	return res;
@@ -2497,6 +2962,8 @@ static int unload_module(void)
 	ast_manager_unregister("Park");
 	ast_cli_unregister_multiple(cli_features, sizeof(cli_features) / sizeof(struct ast_cli_entry));
 	ast_unregister_application(parkcall);
+ 	ast_unregister_application(autoanswer);
+ 	ast_unregister_application(autoanswerlogin);
 	ast_devstate_prov_del("Park");
 	return ast_unregister_application(parkedcall);
 }
