Change the ABI of ast_channel_tech to add a new function, send_message that is
to be used by channels wanting to send text messages with a destination number
(mainly GSM).

--- a/include/asterisk/channel.h
+++ b/include/asterisk/channel.h
@@ -247,6 +247,11 @@ struct ast_channel_tech {
 	/*! \brief Display or transmit text */
 	int (* const send_text)(struct ast_channel *chan, const char *text);
 
+#if 0 /* we (Debian) disable that addition because of ABI breakage */
+	/*! \brief send a message */
+	int (* const send_message)(struct ast_channel *chan, const char *dest, const char *text, int ispdu);
+#endif
+
 	/*! \brief Display or send an image */
 	int (* const send_image)(struct ast_channel *chan, struct ast_frame *frame);
 
@@ -689,6 +694,16 @@ struct ast_channel *ast_request_and_dial
 
 struct ast_channel *__ast_request_and_dial(const char *type, int format, void *data, int timeout, int *reason, const char *cidnum, const char *cidname, struct outgoing_helper *oh);
 
+/*! \brief "Requests" a channel for sending a message
+ * \param type type of channel to request
+ * \param data data to pass to the channel requester
+ * \param status status
+ * Request a channel of a given type, with data as optional information used
+ * by the low level module
+ * \return Returns 0 on success, -1 on failure.
+ */
+int ast_send_message(const char *type, void *data, char *to, char *from, char *message, int ispdu);
+
 /*!\brief Register a channel technology (a new channel driver)
  * Called by a channel module to register the kind of channels it supports.
  * \param tech Structure defining channel technology or "type"
@@ -910,6 +925,16 @@ int ast_set_write_format(struct ast_chan
  */
 int ast_sendtext(struct ast_channel *chan, const char *text);
 
+/*! \brief Sends message to a channel
+ * Write text to a display on a channel
+ * \param chan channel to act upon
+ * \param dest destination number/user
+ * \param text string of text to send on the channel
+ * \param ispdu message is in PDU format
+ * \return Returns 0 on success, -1 on failure
+ */
+int ast_sendmessage(struct ast_channel *chan, const char *dest, const char *text, int ispdu);
+
 /*! \brief Receives a text character from a channel
  * \param chan channel to act upon
  * \param timeout timeout in milliseconds (0 for infinite wait)
--- a/main/channel.c
+++ b/main/channel.c
@@ -2472,6 +2472,21 @@ int ast_sendtext(struct ast_channel *cha
 	return res;
 }
 
+int ast_sendmessage(struct ast_channel *chan, const char *dest, const char *text, int ispdu)
+{
+	int res = 0;
+	/* Stop if we're a zombie or need a soft hangup */
+	if (ast_test_flag(chan, AST_FLAG_ZOMBIE) || ast_check_hangup(chan))
+		return -1;
+	CHECK_BLOCKING(chan);
+#if 0 /* we (Debian) disable that addition because of ABI breakage */
+	if (chan->tech->send_message)
+		res = chan->tech->send_message(chan, dest, text, ispdu);
+#endif
+	ast_clear_flag(chan, AST_FLAG_BLOCKING);
+	return res;
+}
+
 int ast_senddigit_begin(struct ast_channel *chan, char digit)
 {
 	/* Device does not support DTMF tones, lets fake
@@ -4515,6 +4530,25 @@ void ast_channel_stop_silence_generator(
 }
 
 
+int ast_send_message(const char *type, void *data, char *to, char *from, char *message, int ispdu) {
+	struct ast_channel *chan = NULL;
+	int status;
+	int res = -1;
+
+	chan = ast_request(type, AST_FORMAT_SLINEAR, data, &status);
+	if (chan) {
+	    if (from) {
+		ast_set_callerid(chan, from, from, from);
+	    }
+	    res = ast_sendmessage(chan, to, message, ispdu);
+	    /* XXX what about message CDRs ??? XXX */
+	    ast_hangup(chan);
+	    return res;
+	}
+
+	return res;
+}
+
 /*! \ brief Convert channel reloadreason (ENUM) to text string for manager event */
 const char *channelreloadreason2txt(enum channelreloadreason reason)
 {
--- a/main/manager.c
+++ b/main/manager.c
@@ -11,6 +11,9 @@
  * the project provides a web site, mailing lists and IRC
  * channels for your use.
  *
+ * Copyright (C) 2003-2004, Junghanns.NET Gmbh
+ * Klaus-Peter Junghanns <kpj@junghanns.net>
+ *
  * This program is free software, distributed under the terms of
  * the GNU General Public License Version 2. See the LICENSE file
  * at the top of the source tree.
@@ -1430,6 +1433,49 @@ static int action_hangup(struct mansessi
 	return 0;
 }
 
+static char mandescr_message[] =
+"Description: Send a message\n"
+"Variables: \n"
+"	Channel: The destination channel(e.g. SIP/phone1)\n"
+"	From:	 \n"
+"	Message: The message to send\n";
+
+static int action_message(struct mansession *s, const struct message *m)
+{
+	const char *name = astman_get_header(m, "Channel");
+	const char *from = astman_get_header(m, "From");
+	const char *message = astman_get_header(m, "Message");
+	const char *pdu = astman_get_header(m, "PDU");
+	char tmp[256];
+	char *tech, *data;
+	int res;
+	if (ast_strlen_zero(name) || (ast_strlen_zero(message) && ast_strlen_zero(pdu))) {
+		astman_send_error(s, m, "No channel or message/PDU specified");
+		return 0;
+	}
+	ast_copy_string(tmp, name, sizeof(tmp));
+	tech = tmp;
+	data = strchr(tmp, '/');
+	if (!data) {
+		astman_send_error(s, m, "Invalid channel\n");
+		return 0;
+	}
+	*data = '\0';
+	data++;
+	if (ast_strlen_zero(pdu)) {
+	    res = ast_send_message(tech, (char *)data, (char *)name, (char *)from, (char *)message, 0);
+	} else {
+	    res = ast_send_message(tech, (char *)data, (char *)name, (char *)from, (char *)pdu, 1);
+	}
+
+	if (res) {
+		astman_send_error(s, m, "Error sending message");
+		return 0;
+	}
+	astman_send_ack(s, m, "Message sent");
+	return 0;
+}
+
 static char mandescr_setvar[] = 
 "Description: Set a global or local channel variable.\n"
 "Variables: (Names marked with * are required)\n"
@@ -2894,6 +2940,7 @@ int init_manager(void)
 		ast_manager_register2("Events", 0, action_events, "Control Event Flow", mandescr_events);
 		ast_manager_register2("Logoff", 0, action_logoff, "Logoff Manager", mandescr_logoff);
 		ast_manager_register2("Hangup", EVENT_FLAG_CALL, action_hangup, "Hangup Channel", mandescr_hangup);
+		ast_manager_register2("Message", EVENT_FLAG_CALL, action_message, "Send Message", mandescr_message);
 		ast_manager_register("Status", EVENT_FLAG_CALL, action_status, "Lists channel status" );
 		ast_manager_register2("Setvar", EVENT_FLAG_CALL, action_setvar, "Set Channel Variable", mandescr_setvar );
 		ast_manager_register2("Getvar", EVENT_FLAG_CALL, action_getvar, "Gets a Channel Variable", mandescr_getvar );
--- a/pbx/pbx_spool.c
+++ b/pbx/pbx_spool.c
@@ -87,6 +87,10 @@ struct outgoing {
 	char app[256];
 	char data[256];
 
+	/* If SMS */
+	char message[256];
+	char pdu[256];
+
 	/* If extension/context/priority */
 	char exten[256];
 	char context[256];
@@ -181,6 +185,10 @@ static int apply_outgoing(struct outgoin
 					ast_copy_string(o->app, c, sizeof(o->app));
 				} else if (!strcasecmp(buf, "data")) {
 					ast_copy_string(o->data, c, sizeof(o->data));
+				} else if (!strcasecmp(buf, "message")) {
+					strncpy(o->message, c, sizeof(o->message) - 1);
+				} else if (!strcasecmp(buf, "pdu")) {
+					strncpy(o->pdu, c, sizeof(o->pdu) - 1);
 				} else if (!strcasecmp(buf, "maxretries")) {
 					if (sscanf(c, "%d", &o->maxretries) != 1) {
 						ast_log(LOG_WARNING, "Invalid max retries at line %d of %s\n", lineno, fn);
@@ -241,8 +249,8 @@ static int apply_outgoing(struct outgoin
 		}
 	}
 	ast_copy_string(o->fn, fn, sizeof(o->fn));
-	if (ast_strlen_zero(o->tech) || ast_strlen_zero(o->dest) || (ast_strlen_zero(o->app) && ast_strlen_zero(o->exten))) {
-		ast_log(LOG_WARNING, "At least one of app or extension must be specified, along with tech and dest in file %s\n", fn);
+	if (ast_strlen_zero(o->tech) || ast_strlen_zero(o->dest) || ((ast_strlen_zero(o->app) && ast_strlen_zero(o->exten) && ast_strlen_zero(o->message) && ast_strlen_zero(o->pdu)))) {
+		ast_log(LOG_WARNING, "At least one of app or extension (or keyword message/pdu)must be specified, along with tech and dest in file %s\n", fn);
 		return -1;
 	}
 	return 0;
@@ -332,6 +340,14 @@ static void *attempt_thread(void *data)
 		if (option_verbose > 2)
 			ast_verbose(VERBOSE_PREFIX_3 "Attempting call on %s/%s for application %s(%s) (Retry %d)\n", o->tech, o->dest, o->app, o->data, o->retries);
 		res = ast_pbx_outgoing_app(o->tech, AST_FORMAT_SLINEAR, o->dest, o->waittime * 1000, o->app, o->data, &reason, 2 /* wait to finish */, o->cid_num, o->cid_name, o->vars, o->account, NULL);
+	} else if (!ast_strlen_zero(o->message)) {
+		if (option_verbose > 2)
+			ast_verbose(VERBOSE_PREFIX_3 "Attempting to send message on %s/%s (Retry %d)\n", o->tech, o->dest, o->retries);
+		res = ast_send_message(o->tech, o->dest, o->dest, (ast_strlen_zero(o->cid_name) ? o->cid_num : o->cid_name), o->message, 0);
+	} else if (!ast_strlen_zero(o->pdu)) {
+		if (option_verbose > 2)
+			ast_verbose(VERBOSE_PREFIX_3 "Attempting to send message in PDU format on %s/%s (Retry %d)\n", o->tech, o->dest, o->retries);
+		res = ast_send_message(o->tech, o->dest, o->dest, (ast_strlen_zero(o->cid_name) ? o->cid_num : o->cid_name), o->pdu, 1);
 	} else {
 		if (option_verbose > 2)
 			ast_verbose(VERBOSE_PREFIX_3 "Attempting call on %s/%s for %s@%s:%d (Retry %d)\n", o->tech, o->dest, o->exten, o->context,o->priority, o->retries);
@@ -348,9 +364,14 @@ static void *attempt_thread(void *data)
 			safe_append(o, time(NULL), "EndRetry");
 		}
 	} else {
+	    if (!ast_strlen_zero(o->message)) {
+		if (option_verbose > 2)
+		    ast_verbose(VERBOSE_PREFIX_2 "Message sent to %s/%s\n", o->tech, o->dest);
+	    } else {
 		ast_log(LOG_NOTICE, "Call completed to %s/%s\n", o->tech, o->dest);
 		ast_log(LOG_EVENT, "Queued call to %s/%s completed\n", o->tech, o->dest);
-		remove_from_queue(o, "Completed");
+	    }
+	    remove_from_queue(o, "Completed");
 	}
 	free_outgoing(o);
 	return NULL;
