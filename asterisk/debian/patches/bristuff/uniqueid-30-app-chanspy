--- a/apps/app_chanspy.c
+++ b/apps/app_chanspy.c
@@ -57,6 +57,7 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 
 static const char *tdesc = "Listen to a channel, and optionally whisper into it";
 static const char *app_chan = "ChanSpy";
+static const char *app_chan_uniqueid = "ChanSpyChan";
 static const char *desc_chan = 
 "  ChanSpy([chanprefix][|options]): This application is used to listen to the\n"
 "audio from an Asterisk channel. This includes the audio coming in and\n"
@@ -87,6 +88,27 @@ static const char *desc_chan = 
 "                    channel.\n"
 ;
 
+static const char *desc_uniqueid =
+"  ChanSpyChan(uniqueid[|options]): This application is used to listen to the\n"
+"audio from an Asterisk channel. This includes the audio coming in and\n"
+"out of the channel being spied on. The 'uniqueid' parameter has to be specified,\n"
+"  While spying, the following actions may be performed:\n"
+"    - Dialing # cycles the volume level.\n"
+"  Options:\n"
+"    q             - Don't play a beep when beginning to spy on a channel, or speak the\n"
+"                    selected channel name.\n"
+"    r[(basename)] - Record the session to the monitor spool directory. An\n"
+"                    optional base for the filename may be specified. The\n"
+"                    default is 'chanspy'.\n"
+"    v([value])    - Adjust the initial volume in the range from -4 to 4. A\n"
+"                    negative value refers to a quieter setting.\n"
+"    w             - Enable 'whisper' mode, so the spying channel can talk to\n"
+"                    the spied-on channel.\n"
+"    W             - Enable 'private whisper' mode, so the spying channel can\n"
+"                    talk to the spied-on channel but cannot listen to that\n"
+"                    channel.\n"
+;
+
 static const char *app_ext = "ExtenSpy";
 static const char *desc_ext = 
 "  ExtenSpy(exten[@context][|options]): This application is used to listen to the\n"
@@ -458,7 +480,7 @@ static struct chanspy_ds *setup_chanspy_
 
 static struct chanspy_ds *next_channel(struct ast_channel *chan,
 	const struct ast_channel *last, const char *spec,
-	const char *exten, const char *context, struct chanspy_ds *chanspy_ds)
+	const char *exten, const char *context, struct chanspy_ds *chanspy_ds, const char *uniqueid)
 {
 	struct ast_channel *this;
 
@@ -467,6 +489,8 @@ redo:
 		this = ast_walk_channel_by_name_prefix_locked(last, spec, strlen(spec));
 	else if (exten)
 		this = ast_walk_channel_by_exten_locked(last, exten, context);
+	else if (uniqueid)
+		this = ast_get_channel_by_uniqueid_locked(uniqueid);
 	else
 		this = ast_channel_walk_locked(last);
 
@@ -487,7 +511,7 @@ redo:
 
 static int common_exec(struct ast_channel *chan, const struct ast_flags *flags,
 		       int volfactor, const int fd, const char *mygroup, const char *spec,
-		       const char *exten, const char *context)
+		       const char *exten, const char *context, const char *uniqueid)
 {
 	char nameprefix[AST_NAME_STRLEN];
 	char peer_name[AST_NAME_STRLEN + 5];
@@ -534,11 +558,11 @@ static int common_exec(struct ast_channe
 		waitms = 100;
 		num_spyed_upon = 0;
 
-		for (peer_chanspy_ds = next_channel(chan, prev, spec, exten, context, &chanspy_ds);
+		for (peer_chanspy_ds = next_channel(chan, prev, spec, exten, context, &chanspy_ds, NULL);
 		     peer_chanspy_ds;
 			 chanspy_ds_free(peer_chanspy_ds), prev = peer,
 		     peer_chanspy_ds = next_chanspy_ds ? next_chanspy_ds : 
-			 	next_channel(chan, prev, spec, exten, context, &chanspy_ds), next_chanspy_ds = NULL) {
+			 	next_channel(chan, prev, spec, exten, context, &chanspy_ds, NULL), next_chanspy_ds = NULL) {
 			const char *group;
 			int igrp = !mygroup;
 			char *groups[25];
@@ -737,7 +761,7 @@ static int chanspy_exec(struct ast_chann
 		}
 	}
 
-	res = common_exec(chan, &flags, volfactor, fd, mygroup, spec, NULL, NULL);
+	res = common_exec(chan, &flags, volfactor, fd, mygroup, spec, NULL, NULL, NULL);
 
 	if (fd)
 		close(fd);
@@ -822,7 +846,7 @@ static int extenspy_exec(struct ast_chan
 		}
 	}
 
-	res = common_exec(chan, &flags, volfactor, fd, mygroup, NULL, exten, context);
+	res = common_exec(chan, &flags, volfactor, fd, mygroup, NULL, exten, context, NULL);
 
 	if (fd)
 		close(fd);
@@ -835,14 +859,100 @@ static int extenspy_exec(struct ast_chan
 	return res;
 }
 
+static int chanspychan_exec(struct ast_channel *chan, void *data)
+{
+	struct ast_module_user *u;
+	char *options = NULL;
+	char *uniqueid = NULL;
+	char *argv[2];
+	char *mygroup = NULL;
+	char *recbase = NULL;
+	int fd = 0;
+	struct ast_flags flags;
+	int oldwf = 0;
+	int argc = 0;
+	int volfactor = 0;
+	int res;
+
+	data = ast_strdupa(data);
+
+	u = ast_module_user_add(chan);
+
+	if ((argc = ast_app_separate_args(data, '|', argv, sizeof(argv) / sizeof(argv[0])))) {
+		uniqueid = argv[0];
+		if (argc > 1)
+			options = argv[1];
+
+		if (ast_strlen_zero(uniqueid)) {
+			ast_log(LOG_ERROR, "no uniqueid specified.\n");
+			ast_module_user_remove(u);
+			return -1;
+		}
+	}
+
+	if (options) {
+		char *opts[OPT_ARG_ARRAY_SIZE];
+
+		ast_app_parse_options(spy_opts, &flags, opts, options);
+		if (ast_test_flag(&flags, OPTION_GROUP))
+			mygroup = opts[OPT_ARG_GROUP];
+
+		if (ast_test_flag(&flags, OPTION_RECORD) &&
+		    !(recbase = opts[OPT_ARG_RECORD]))
+			recbase = "chanspy";
+
+		if (ast_test_flag(&flags, OPTION_VOLUME) && opts[OPT_ARG_VOLUME]) {
+			int vol;
+
+			if ((sscanf(opts[OPT_ARG_VOLUME], "%d", &vol) != 1) || (vol > 4) || (vol < -4))
+				ast_log(LOG_NOTICE, "Volume factor must be a number between -4 and 4\n");
+			else
+				volfactor = vol;
+		}
+
+		if (ast_test_flag(&flags, OPTION_PRIVATE))
+			ast_set_flag(&flags, OPTION_WHISPER);
+	}
+
+	oldwf = chan->writeformat;
+	if (ast_set_write_format(chan, AST_FORMAT_SLINEAR) < 0) {
+		ast_log(LOG_ERROR, "Could Not Set Write Format.\n");
+		ast_module_user_remove(u);
+		return -1;
+	}
+
+	if (recbase) {
+		char filename[512];
+
+		snprintf(filename, sizeof(filename), "%s/%s.%d.raw", ast_config_AST_MONITOR_DIR, recbase, (int) time(NULL));
+		if ((fd = open(filename, O_CREAT | O_WRONLY | O_TRUNC, 0644)) <= 0) {
+			ast_log(LOG_WARNING, "Cannot open '%s' for recording\n", filename);
+			fd = 0;
+		}
+	}
+
+	res = common_exec(chan, &flags, volfactor, fd, mygroup, NULL, NULL, NULL, uniqueid);
+
+	if (fd)
+		close(fd);
+
+	if (oldwf && ast_set_write_format(chan, oldwf) < 0)
+		ast_log(LOG_ERROR, "Could Not Set Write Format.\n");
+
+	ast_module_user_remove(u);
+
+	return res;
+}
+
+
 static int unload_module(void)
 {
 	int res = 0;
 
 	res |= ast_unregister_application(app_chan);
+	res |= ast_unregister_application(app_chan_uniqueid);
 	res |= ast_unregister_application(app_ext);
 
-	ast_module_user_hangup_all();
 
 	return res;
 }
@@ -853,6 +963,7 @@ static int load_module(void)
 
 	res |= ast_register_application(app_chan, chanspy_exec, tdesc, desc_chan);
 	res |= ast_register_application(app_ext, extenspy_exec, tdesc, desc_ext);
+	res |= ast_register_application(app_chan_uniqueid, chanspychan_exec, tdesc, desc_uniqueid);
 
 	return res;
 }
