--- a/main/pbx.c
+++ b/main/pbx.c
@@ -5146,7 +5146,7 @@ struct app_tmp {
 };
 
 /*! \brief run the application and free the descriptor once done */
-static void *ast_pbx_run_app(void *data)
+void *ast_pbx_run_app(void *data)
 {
 	struct app_tmp *tmp = data;
 	struct ast_app *app;
--- a/include/asterisk/pbx.h
+++ b/include/asterisk/pbx.h
@@ -145,6 +145,8 @@ void ast_unregister_switch(struct ast_sw
  */
 struct ast_app *pbx_findapp(const char *app);
 
+void *ast_pbx_run_app(void *data);
+
 /*!
  * \brief Execute an application
  *
--- a/channels/chan_zap.c
+++ b/channels/chan_zap.c
@@ -304,6 +304,19 @@ struct zt_suspended_call {
 	struct zt_suspended_call *next;
 };
 
+struct zt_holded_call {
+	ast_mutex_t lock;		/* Mutex */
+	char msn[AST_MAX_EXTENSION];	/* the MSN to which this parked call belongs */
+	char uniqueid[AST_MAX_EXTENSION];	/* unique id of the onhold channel */
+	int tei;
+	int cref;
+	int alreadyhungup;
+	struct ast_channel *channel;
+	struct ast_channel *bridge;
+	q931_call *call;	/* this also covers tei mumbojumbo */
+	struct zt_holded_call *next;
+};
+
 struct zt_pri {
 	pthread_t master;						/*!< Thread of master */
 	ast_mutex_t lock;						/*!< Mutex */
@@ -347,6 +360,7 @@ struct zt_pri {
 	struct zt_pvt *crvs;						/*!< Member CRV structs */
 	struct zt_pvt *crvend;						/*!< Pointer to end of CRV structs */
  	struct zt_suspended_call *suspended_calls; /* Calls parked with SUSPEND messages */
+ 	struct zt_holded_call *holded_calls; /* Calls on hold */
 	int debugfd;
 };
 
@@ -7490,6 +7504,7 @@ static struct zt_pvt *mkintf(int channel
 						pris[span].overlapdial = conf.pri.overlapdial;
 						pris[span].usercid = conf.pri.usercid;
 						pris[span].suspended_calls = NULL;
+						pris[span].holded_calls = NULL;
 						pris[span].facilityenable = conf.pri.facilityenable;
 						ast_copy_string(pris[span].idledial, conf.pri.idledial, sizeof(pris[span].idledial));
 						ast_copy_string(pris[span].idleext, conf.pri.idleext, sizeof(pris[span].idleext));
@@ -8174,6 +8189,58 @@ static struct zt_pvt *pri_find_crv(struc
 	return NULL;
 }
 
+static int pri_find_tei(struct zt_pri *pri, q931_call *c, int tei)
+{
+	int x=0;
+	for (x=0;x<pri->numchans;x++) {
+		if (!pri->pvts[x]) continue;
+		if ((pri->pvts[x]->tei == tei) && (pri->pvts[x]-> call != c)) {
+		    return x;
+		}
+	}
+	return -1;
+}
+
+static struct zt_holded_call *pri_get_callonhold(struct zt_pri *pri, int cref, int tei) {
+	struct zt_holded_call *zhc = pri->holded_calls;
+	struct zt_holded_call *zhctemp = NULL;
+
+	while (zhc) {
+	    if ((zhc->tei == tei) && ((zhc->cref == cref) || (cref == -1))) {
+		return zhc;
+	    }
+	    zhctemp = zhc;
+	    if (zhc) zhc = zhc->next;
+	}
+	return NULL;
+}
+
+static int pri_destroy_callonhold(struct zt_pri *pri, struct zt_holded_call *onhold) {
+	struct zt_holded_call *zhc = pri->holded_calls;
+	struct zt_holded_call *zhctemp = NULL;
+
+	while (zhc) {
+	    if (zhc == onhold) {
+		if (zhctemp) {
+		    zhctemp->next = zhc->next;
+		    zhc = zhctemp;
+		} else {
+		    pri->holded_calls = zhc->next;
+		    zhc = pri->holded_calls;
+		    zhctemp = NULL;
+		}
+	    }
+	    zhctemp = zhc;
+	    if (zhc) zhc = zhc->next;
+	}
+	if (onhold) {
+	    free(onhold);
+	    onhold = NULL;
+	    return 1;
+	}
+	return 0;
+}
+
 
 static int pri_find_principle(struct zt_pri *pri, int channel)
 {
@@ -9589,18 +9656,150 @@ static void *pri_dchannel(void *vpri)
 				    pri_hold_reject(pri->pri, e->hold_req.call);
 				    break;
 				}
-				/* holded calls are not implemented yet */
-				pri_hold_reject(pri->pri, e->hold_req.call);
+				chanpos = pri_find_principle(pri, e->hold_req.channel);
+				if (chanpos < 0)  {
+					ast_log(LOG_WARNING, "Hold requested on unconfigured channel %d span %d\n", chanpos, pri->span);
+					chanpos = -1;
+				}
+				if (chanpos > -1) {
+				//    ast_log(LOG_NOTICE, "Hold request for channel number %d span %d\n", chanpos, pri->span);
+				    ast_mutex_lock(&pri->pvts[chanpos]->lock);
+ 				    if (pri->pvts[chanpos]->owner) {
+					struct zt_pvt *p = pri->pvts[chanpos];
+					struct zt_holded_call *zhc;
+					int holdacked=0;
+
+//					ast_log(LOG_NOTICE,"HOLD request from channel %s tei %d\n",p->owner->name, e->hold_req.tei);
+				    	if (ast_bridged_channel(p->owner)) {
+					    zhc = malloc(sizeof(struct zt_holded_call));
+					    if (!zhc) {
+						ast_log(LOG_ERROR, "unable to malloc zt_holded_call\n");
+						break;
+					    }
+					    memset(zhc, 0, sizeof(zhc));
+					    strncpy(zhc->msn,  pri->pvts[chanpos]->cid_num, sizeof(zhc->msn));
+					    strncpy(zhc->uniqueid,  ast_bridged_channel(p->owner)->uniqueid, sizeof(zhc->uniqueid));
+					    zhc->tei = e->hold_req.tei;
+					    zhc->cref = e->hold_req.cref;
+					    zhc->call = e->hold_req.call;
+					    zhc->channel = p->owner;
+					    zhc->alreadyhungup = 0;
+					    zhc->bridge = ast_bridged_channel(p->owner);
+					    zhc->next = pri->holded_calls;
+					    pri->holded_calls = zhc;
+
+					    /* put channel on hold */
+					    ast_masq_hold_call(ast_bridged_channel(p->owner), p->owner);
+
+					    pri_hold_acknowledge(pri->pri, e->hold_req.call);
+					    holdacked = 1;
+					    p->call = NULL; // free the bchannel withouth destroying the call
+					    p->tei = -1;
+					} else {
+					    // cant hold a non-bridge,...yet
+
+					    // make a fake channel
+
+					    // masquerade
+
+					    // put on hold
+					    pri_hold_reject(pri->pri, e->hold_req.call);
+					}
+				    } else {
+					    pri_hold_reject(pri->pri, e->hold_req.call);
+				    }
+				    ast_mutex_unlock(&pri->pvts[chanpos]->lock);
+				} else {
+					pri_hold_reject(pri->pri, e->hold_req.call);
+				}
 				break;
 			case PRI_EVENT_RETRIEVE_REQ:
 				if ((pri->nodetype != BRI_NETWORK_PTMP) && (pri->nodetype != BRI_NETWORK)) {
 				    pri_retrieve_reject(pri->pri, e->retrieve_req.call);
 				    break;
 				}
-				/* Holded calls are currently not supported */
-				pri_retrieve_reject(pri->pri, e->retrieve_req.call);
-				chanpos = -1;
-				break;
+				chanpos = pri_find_empty_chan(pri, 1);
+				if (chanpos < 0) {
+					pri_retrieve_reject(pri->pri, e->retrieve_req.call);
+					ast_log(LOG_WARNING, "Retrieve requested on odd channel number %d span %d\n", chanpos, pri->span);
+					chanpos = -1;
+					break;
+				} else if (!pri->pvts[chanpos]) {
+					ast_log(LOG_WARNING, "Retrieve requested on unconfigured channel number %d span %d\n", chanpos, pri->span);
+					pri_retrieve_reject(pri->pri, e->retrieve_req.call);
+					chanpos = -1;
+					break;
+				}
+				if (chanpos > -1) {
+				    struct zt_holded_call *onhold = NULL;
+				    int retrieved = 0;
+				    int res = -1;
+				    struct app_tmp *tmp;
+				    pthread_attr_t attr;
+				    int law;
+
+				    onhold = pri_get_callonhold(pri, e->retrieve_req.cref, e->retrieve_req.tei);
+
+				    if (!onhold) {
+					pri_retrieve_reject(pri->pri, e->retrieve_req.call);
+					break;
+				    }
+				    ast_mutex_lock(&pri->pvts[chanpos]->lock);
+					// found a parked call
+ 					law = 1;
+					if (ioctl(pri->pvts[chanpos]->subs[SUB_REAL].zfd, ZT_AUDIOMODE, &law) == -1)
+					    ast_log(LOG_WARNING, "Unable to set audio mode on channel %d to %d\n", PVT_TO_CHANNEL(pri->pvts[chanpos]), law);
+					// uhh ohh...what shall we do without the bearer cap???
+					law = ZT_LAW_ALAW;
+					res = zt_setlaw(pri->pvts[chanpos]->subs[SUB_REAL].zfd, law);
+					if (res < 0)
+					    ast_log(LOG_WARNING, "Unable to set law on channel %d\n", PVT_TO_CHANNEL(pri->pvts[chanpos]));
+					res = set_actual_gain(pri->pvts[chanpos]->subs[SUB_REAL].zfd, 0, pri->pvts[chanpos]->rxgain, pri->pvts[chanpos]->txgain, law);
+					if (res < 0)
+					    ast_log(LOG_WARNING, "Unable to set gains on channel %d\n", PVT_TO_CHANNEL(pri->pvts[chanpos]));
+					/* Start PBX */
+					c = zt_new(pri->pvts[chanpos], AST_STATE_UP, 0, SUB_REAL, law, PRI_TRANS_CAP_SPEECH);
+					if (c) {
+					    pri->pvts[chanpos]->owner = c;
+					    pri->pvts[chanpos]->outgoing = 1; /* for not sending proceedings... */
+					    pri->pvts[chanpos]->call = e->retrieve_req.call;
+					    pri->pvts[chanpos]->tei = e->retrieve_req.tei;
+				    	    zt_enable_ec(pri->pvts[chanpos]);
+				    	    zt_train_ec(pri->pvts[chanpos]);
+					} else {
+					    ast_log(LOG_ERROR, "unable to start pbx\n");
+					}
+
+					retrieved = 1;
+				//	ast_log(LOG_NOTICE, "sending RETRIEVE ACK on channel %d, span %d for tei %d cref %d\n",chanpos,pri->span, e->retrieve_req.tei,  e->retrieve_req.cref);
+					pri_retrieve_acknowledge(pri->pri, e->retrieve_req.call, chanpos + 1);
+
+					// the magic begins here: ....
+					tmp = malloc(sizeof(struct app_tmp));
+					if (tmp) {
+					    memset(tmp, 0, sizeof(struct app_tmp));
+					    strncpy(tmp->app, "holdedcall", sizeof(tmp->app) - 1);
+					    strncpy(tmp->data, onhold->uniqueid, sizeof(tmp->data) - 1);
+					    tmp->chan = c;
+					}
+					pri_destroy_callonhold(pri, onhold);
+					onhold = NULL;
+
+					ast_mutex_unlock(&pri->pvts[chanpos]->lock);
+					pthread_attr_init(&attr);
+					pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
+					if (ast_pthread_create(&tmp->t, &attr, ast_pbx_run_app, tmp)) {
+ 					    ast_log(LOG_WARNING, "Unable to spawn execute thread on %s: %s\n", c->name, strerror(errno));
+					    free(tmp);
+					    ast_hangup(c);
+					    retrieved = 0;
+					}
+
+				    if (!retrieved) {
+					pri_retrieve_reject(pri->pri, e->retrieve_req.call);
+				    }
+				}
+ 				break;
 			case PRI_EVENT_DISPLAY_RECEIVED:
 				ast_log(LOG_NOTICE, "DISPLAY IE: [ %s ] received\n",e->display.text);
 				chanpos = pri_find_principle(pri, e->display.channel);
@@ -9757,9 +9956,20 @@ static void *pri_dchannel(void *vpri)
 
 						ast_mutex_unlock(&pri->pvts[chanpos]->lock);
 					} else {
-						ast_log(LOG_NOTICE, "Hangup, did not find cref %d, tei %d\n",e->hangup.cref, e->hangup.tei);
-						ast_log(LOG_WARNING, "Hangup on bad channel %d/%d on span %d\n",
-								PRI_SPAN(e->hangup.channel), PRI_CHANNEL(e->hangup.channel), pri->span);
+ 						struct zt_holded_call *onhold = NULL;
+						/* check calls on hold */
+ 						onhold = pri_get_callonhold(pri, e->hangup.cref, e->hangup.tei);
+
+ 						if (onhold) {
+ 						    // ast_log(LOG_NOTICE, "hangup, found cref %d, tei %d\n",e->hangup.cref, e->hangup.tei);
+ 						    pri_hangup(pri->pri, onhold->call, e->hangup.cause, -1);
+ 						    pri_destroy_callonhold(pri, onhold);
+ 						    onhold = NULL;
+ 						} else {
+ 						    ast_log(LOG_NOTICE, "Hangup, did not find cref %d, tei %d\n",e->hangup.cref, e->hangup.tei);
+ 						    ast_log(LOG_WARNING, "Hangup on bad channel %d/%d on span %d\n",
+  							PRI_SPAN(e->hangup.channel), PRI_CHANNEL(e->hangup.channel), pri->span);
+ 						}
 					}
 				} 
 				break;
@@ -9822,11 +10032,63 @@ static void *pri_dchannel(void *vpri)
 							    	ast_verbose(VERBOSE_PREFIX_3 "Channel %d/%d, span %d received AOC-E charging %d unit%s\n",
 									pri->pvts[chanpos]->logicalspan, pri->pvts[chanpos]->prioffset, pri->span, (int)e->hangup.aoc_units, (e->hangup.aoc_units == 1) ? "" : "s");
 							}
-							if (pri->nodetype == BRI_NETWORK_PTMP) {
-								pri_hangup(pri->pri, pri->pvts[chanpos]->call, e->hangup.cause, -1);
-								pri->pvts[chanpos]->call = NULL;
-								pri->pvts[chanpos]->tei = -1;
-							}
+ 							if (pri->nodetype == BRI_NETWORK_PTMP) {
+							    // check for bri transfers, not everybody uses ECT...
+ 							    if (pri->pvts[chanpos]->owner) {
+ 								// find on hold call
+								struct zt_holded_call *onhold = NULL;
+ 								struct ast_channel *transferee = NULL;
+								int transfer_ok = 0;
+
+ 								onhold = pri_get_callonhold(pri, -1, e->hangup.tei);
+
+ 								if (onhold) {
+								    if (pri->pvts[chanpos]->pritransfer == 2) {
+ 									if (((pri->pvts[chanpos]->owner->_state != AST_STATE_RING) && (pri->pvts[chanpos]->owner->_state != AST_STATE_RESERVED)) || ((!ast_strlen_zero(pri->pvts[chanpos]->exten)) && (strncasecmp(pri->pvts[chanpos]->exten, "s", sizeof(pri->pvts[chanpos]->exten))))) {
+ 								    	    transferee = ast_get_holded_call(onhold->uniqueid);
+
+ 									    if (transferee) {
+ 										if (pri->pvts[chanpos]->owner->_state == AST_STATE_RINGING) {
+ 									    	    ast_indicate(transferee, AST_CONTROL_RINGING);
+ 										}
+
+ 										pri->pvts[chanpos]->owner->_softhangup &= ~AST_SOFTHANGUP_DEV;
+
+  									        ast_mutex_unlock(&transferee->lock);
+ 										if (ast_channel_masquerade(pri->pvts[chanpos]->owner, transferee)) {
+ 										    ast_log(LOG_WARNING, "unable to masquerade\n");
+ 									        } else {
+ 									    	    /* beware of zombies!!! */
+										    ast_set_flag(transferee, AST_FLAG_ZOMBIE);
+ 										    pri->pvts[chanpos]->owner = NULL;
+ 										    pri->pvts[chanpos]->tei = -1;
+										    transfer_ok = 1;
+ 										}
+ 									    }
+									}
+ 								    } else if (pri->pvts[chanpos]->pritransfer == 0) {
+									ast_log(LOG_NOTICE, "killing channel %s \n", onhold->uniqueid);
+ 									ast_retrieve_call_to_death(onhold->uniqueid);
+									transfer_ok = 1;
+ 								    } else if (pri->pvts[chanpos]->pritransfer == 1) {
+									/* we use ECT transfers, so just ignore this */
+									transfer_ok = 0;
+								    }
+
+								    if (transfer_ok) {
+ 									onhold->alreadyhungup = 1;
+ 									pri_hangup(pri->pri, onhold->call, e->hangup.cause, -1);
+ 									onhold = NULL;
+								    }
+ 								    ast_mutex_unlock(&pri->pvts[chanpos]->lock);
+ 								    break;
+                                                        	} else {
+                                                                    pri_hangup(pri->pri, pri->pvts[chanpos]->call, e->hangup.cause, -1);
+                                                                        pri->pvts[chanpos]->call = NULL;
+                                                                        pri->pvts[chanpos]->tei = -1;
+                                                                }
+  							    }
+  							}
 						} else {
 							pri_hangup(pri->pri, pri->pvts[chanpos]->call, e->hangup.cause, -1);
 							pri->pvts[chanpos]->call = NULL;
@@ -9856,7 +10118,19 @@ static void *pri_dchannel(void *vpri)
  						if (pri->nodetype != BRI_NETWORK_PTMP) {
   						    ast_log(LOG_WARNING, "Hangup REQ on bad channel %d/%d on span %d\n", PRI_SPAN(e->hangup.channel), PRI_CHANNEL(e->hangup.channel), pri->span);
  						} else {
-							ast_log(LOG_WARNING, "Hangup REQ on bad channel %d/%d on span %d\n", PRI_SPAN(e->hangup.channel), PRI_CHANNEL(e->hangup.channel), pri->span);
+ 						    // check holded_calls!!!
+ 						    struct zt_holded_call *onhold = NULL;
+
+ 						    onhold = pri_get_callonhold(pri, e->hangup.cref, e->hangup.tei);
+
+ 						    if (onhold) {
+ 							    pri_hangup(pri->pri, e->hangup.call, e->hangup.cause, -1);
+ 							    ast_retrieve_call_to_death(onhold->uniqueid);
+ 							    pri_destroy_callonhold(pri, onhold);
+ 							    onhold = NULL;
+ 						    } else {
+ 							ast_log(LOG_WARNING, "Hangup REQ on bad channel %d/%d on span %d\n", PRI_SPAN(e->hangup.channel), PRI_CHANNEL(e->hangup.channel), pri->span);
+ 						    }
  						}
 					}
 				} 
@@ -10016,16 +10290,73 @@ static void *pri_dchannel(void *vpri)
 				}
 				break;
  			case PRI_EVENT_FACILITY:
- 				    if (e->facility.operation == 0x0D) {
-				    	struct ast_channel *owner = pri->pvts[chanpos]->owner;
+ 				    if (e->facility.operation == 0x06) {
+ 					struct ast_channel *chan = NULL;
+ 					struct zt_holded_call *onhold = NULL;
+ 					if (option_verbose > 2) {
+ 					    ast_verbose(VERBOSE_PREFIX_3 "ECT requested by TEI %d for cref %d\n", e->facility.tei, e->facility.cref);
+ 					}
+ 					/* search for cref/tei in held calls */
+ 					onhold = pri_get_callonhold(pri, e->facility.cref, e->facility.tei);
+ 					if (onhold) {
+ 					    chan = ast_get_holded_call(onhold->uniqueid);
+ 					    onhold->alreadyhungup = 1;
+ 					    onhold = NULL;
+ 					    if (!chan) {
+ 						/* hang up */
+ 					        pri_hangup(pri->pri, e->facility.call, 16, -1);
+ 						break;
+ 					    }
+ 					} else {
+ 					    /* unknown cref/tei */
+ 					    ast_log(LOG_WARNING, "did not find call on hold for cref %d tei %d\n", e->facility.tei, e->facility.cref);
+ 					    /* hang up */
+ 					    pri_hangup(pri->pri, e->facility.call, 16, -1);
+ 					    break;
+ 					}
 
+ 					/* find an active call for the same tei */
+ 					chanpos = pri_find_tei(pri, e->facility.call, e->facility.tei);
+ 					if (chanpos < 0) {
+ 					    /* did not find active call, hangup call on hold */
+ 					    if (chan) {
+ 						ast_hangup(chan);
+ 						chan = NULL;
+ 					    }
+ 					} else {
+ 					    ast_mutex_lock(&pri->pvts[chanpos]->lock);
+ 					    /* transfer */
+ 					    if (pri->pvts[chanpos]->owner) {
+ 						if (option_verbose > 3) {
+ 						    ast_verbose(VERBOSE_PREFIX_3 "ECT: found %s on channel %d for tei %d\n", pri->pvts[chanpos]->owner->name ,chanpos, e->facility.tei);
+ 						}
+ 						/* pass callprogress if the channel is not up yet */
+ 						if (pri->pvts[chanpos]->owner->_state == AST_STATE_RINGING) {
+ 						    ast_indicate(chan, AST_CONTROL_RINGING);
+ 						}
+ 						/* unlock the channel we removed from hold */
+ 						ast_mutex_unlock(&chan->lock);
+ 						if (ast_channel_masquerade(pri->pvts[chanpos]->owner, chan)) {
+ 					    	    ast_log(LOG_WARNING, "unable to masquerade\n");
+ 						} else {
+ 						    /* beware of zombies !!! */
+						    ast_set_flag(chan, AST_FLAG_ZOMBIE);
+ 						//    chan->zombie = 1;
+ 						}
+ 					    }
+ 					    ast_mutex_unlock(&pri->pvts[chanpos]->lock);
+ 					}
+					/* disconnect */
+ 					pri_hangup(pri->pri, e->facility.call, 16, -1);
+ 				    } else if (e->facility.operation == 0x0D) {
  					ast_log(LOG_NOTICE, "call deflection to %s requested.\n", e->facility.forwardnum);
  					ast_mutex_lock(&pri->pvts[chanpos]->lock);
  					    /* transfer */
- 					    if (owner) {
-						ast_string_field_build(owner, call_forward, 
-								"Local/%s@%s",  e->facility.forwardnum,
-								owner->context);
+ 					    if (pri->pvts[chanpos]->owner) {
+					    	struct ast_channel *owner = pri->pvts[chanpos]->owner;
+							ast_string_field_build(owner, call_forward,
+									"Local/%s@%s", e->facility.forwardnum,
+									owner->context);
  					    }
  					ast_mutex_unlock(&pri->pvts[chanpos]->lock);
  				    } else {
